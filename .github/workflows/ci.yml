name: CI

on:
  push:
    branches: [ main ]
    paths-ignore:
      - 'README.md'
      - 'docs/**'
  pull_request:
    branches: [ '*' ]
    paths-ignore:
      - 'README.md'
      - 'docs/**'
  workflow_dispatch:

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

jobs:
  test:
    name: Test (Node ${{ matrix.node }})
    runs-on: ubuntu-latest
    timeout-minutes: 25
    strategy:
      fail-fast: false
      matrix:
        node: [20.x]
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: campaign_dev
        ports:
          - 5432:5432
        options: >-
          --health-cmd "pg_isready -U postgres" --health-interval 2s --health-timeout 2s --health-retries 30
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping" --health-interval 2s --health-timeout 2s --health-retries 30
    env:
      NODE_ENV: test
      DATABASE_URL: postgresql://postgres:postgres@127.0.0.1:5432/campaign_dev
      REDIS_URL: redis://127.0.0.1:6379

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node ${{ matrix.node }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node }}

      - name: Install pnpm
        env:
          PNPM_VERSION: 10.17.1
        run: |
          echo "Setting up pnpm ${PNPM_VERSION}";
          corepack enable || true
          if command -v corepack >/dev/null 2>&1; then
            corepack prepare pnpm@${PNPM_VERSION} --activate || echo "corepack prepare failed, fallback"
          fi
          if ! command -v pnpm >/dev/null 2>&1; then
            npm install -g pnpm@${PNPM_VERSION}
          fi
          echo "Using pnpm version: $(pnpm -v)"

      - name: Restore pnpm store cache
        uses: actions/cache@v4
        with:
          path: ~/.pnpm-store
          key: pnpm-store-${{ runner.os }}-v1-${{ hashFiles('pnpm-lock.yaml') }}
          restore-keys: |
            pnpm-store-${{ runner.os }}-v1-

      - name: Configure pnpm store path
        run: pnpm config set store-dir ~/.pnpm-store

      - name: Display tool versions
        run: |
          echo "node: $(node -v)"
          echo "pnpm: $(pnpm -v)"
          echo "git sha: $GITHUB_SHA"

      - name: Install dependencies (respect lockfile)
        env:
          CI: true
        run: |
          set -eo pipefail
          if [ -f pnpm-lock.yaml ]; then
            echo "Lockfile present -> attempting frozen install"
            if ! pnpm install --frozen-lockfile; then
              echo "Frozen install failed (lockfile mismatch). Retrying unfrozen..." >&2
              pnpm install --no-frozen-lockfile
            fi
          else
            echo "No pnpm-lock.yaml found -> non-frozen install (consider committing one)" >&2
            pnpm install
          fi
          echo "Store path: $(pnpm store path)"

      - name: Cache Prisma engines
        id: prisma-cache
        uses: actions/cache@v4
        with:
          path: ~/.cache/prisma
          key: prisma-engines-${{ runner.os }}-${{ hashFiles('pnpm-lock.yaml') }}
          restore-keys: |
            prisma-engines-${{ runner.os }}-

      - name: Generate Prisma Client
        working-directory: db
        run: pnpm prisma generate --schema=./prisma/schema.prisma

      - name: Push schema (db push)
        working-directory: db
        run: pnpm prisma db push --schema=./prisma/schema.prisma

      - name: Build packages (ordered)
        run: |
          pnpm --filter @campaign-service/db build
          pnpm --filter @campaign-service/scheduler build
          pnpm --filter @campaign-service/server build

      - name: Typecheck (noEmit)
        run: pnpm -r exec tsc --noEmit --pretty false --skipLibCheck

      - name: Run tests (vitest + coverage)
        run: pnpm test
        env:
          DATABASE_URL: ${{ env.DATABASE_URL }}
          REDIS_URL: ${{ env.REDIS_URL }}

      - name: Upload coverage
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.node }}
          path: coverage
          if-no-files-found: ignore

      - name: Upload junit (if produced)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: junit-${{ matrix.node }}
          path: '**/junit.xml'
          if-no-files-found: ignore

      - name: Summarize coverage (light)
        if: always()
        run: |
          if [ -f coverage/coverage-summary.json ]; then
            lines=$(jq '.total.lines.pct' coverage/coverage-summary.json 2>/dev/null || echo 0)
            statements=$(jq '.total.statements.pct' coverage/coverage-summary.json 2>/dev/null || echo 0)
            branches=$(jq '.total.branches.pct' coverage/coverage-summary.json 2>/dev/null || echo 0)
            functions=$(jq '.total.functions.pct' coverage/coverage-summary.json 2>/dev/null || echo 0)
            echo "Coverage: lines=${lines}% statements=${statements}% branches=${branches}% functions=${functions}%" >> $GITHUB_STEP_SUMMARY
          else
            echo "No coverage summary file found" >> $GITHUB_STEP_SUMMARY
          fi

  docker-images:
    name: Build & (Conditionally) Push Images
    needs: test
    if: needs.test.result == 'success'
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions:
      contents: read
      packages: write
    strategy:
      fail-fast: false
      matrix:
        service: [server, scheduler]
    env:
      REGISTRY: ghcr.io
      IMAGE_NAMESPACE: ${{ github.repository }}
      COMMIT_SHA: ${{ github.sha }}
      # Only push on real GitHub main branch runs (not local act)
      PUSH: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' && github.actor != 'nektos/act' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Debug push conditions
        run: |
          echo "event: ${{ github.event_name }}"
          echo "ref: ${{ github.ref }}"
          echo "actor: ${{ github.actor }}"
          echo "PUSH env (evaluated): ${{ env.PUSH }}"

      - name: Log in to GHCR
        if: env.PUSH == 'true'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract package version
        id: pkg
        run: |
          PKG_PATH="${{ matrix.service }}/package.json"
          if [ -f "$PKG_PATH" ]; then
            VERSION=$(jq -r '.version' "$PKG_PATH")
          else
            VERSION="0.0.0"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Define image tags
        id: tags
        run: |
          SERVICE=${{ matrix.service }}
          LOWER_NAMESPACE=$(echo "$IMAGE_NAMESPACE" | tr '[:upper:]' '[:lower:]')
          BASE="${REGISTRY}/${LOWER_NAMESPACE}"
          TAGS="${BASE}:${SERVICE}-latest,${BASE}:${SERVICE}-${COMMIT_SHA}"
          if [ "${{ steps.pkg.outputs.version }}" != "0.0.0" ]; then
            TAGS+=" ,${BASE}:${SERVICE}-v${{ steps.pkg.outputs.version }}"
          fi
          CLEAN_TAGS=$(echo "$TAGS" | sed 's/, */,/g')
          echo "tags=$CLEAN_TAGS" >> $GITHUB_OUTPUT
          echo "Will build tags: $CLEAN_TAGS (push=$PUSH)"

      - name: Build ${{ matrix.service }} image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ${{ matrix.service }}/Dockerfile
          push: ${{ env.PUSH == 'true' }}
          load: ${{ env.PUSH != 'true' }}
          provenance: false
          sbom: false
          labels: |
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.ref.name=${{ github.ref_name }}
            org.opencontainers.image.title=campaign-${{ matrix.service }}
          tags: ${{ steps.tags.outputs.tags }}
          outputs: type=docker

      - name: Capture image digest
        id: digest
        run: |
          # Attempt to derive digest via docker image inspect (load mode) or build metadata (push mode)
          FIRST_TAG=$(echo "${{ steps.tags.outputs.tags }}" | cut -d',' -f1)
          if docker image inspect "$FIRST_TAG" > /dev/null 2>&1; then
            DIGEST=$(docker image inspect --format '{{index .RepoDigests 0}}' "$FIRST_TAG" || true)
          fi
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT
          echo "Image digest: ${DIGEST:-unavailable}" >> $GITHUB_STEP_SUMMARY

      - name: Summary entry
        run: |
          if [ "${PUSH}" = "true" ]; then
            echo "Pushed image(s) for ${{ matrix.service }}:" >> $GITHUB_STEP_SUMMARY
          else
            echo "Built (not pushed) image(s) for ${{ matrix.service }} (local act run or non-main branch):" >> $GITHUB_STEP_SUMMARY
          fi
          echo "${{ steps.tags.outputs.tags }}" | tr ',' '\n' >> $GITHUB_STEP_SUMMARY
          if [ -n "${{ steps.digest.outputs.digest }}" ]; then
            echo "Digest: ${{ steps.digest.outputs.digest }}" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Force success under act (workaround)
        if: ${{ github.actor == 'nektos/act' && always() }}
        run: echo "Ensuring job success under act; prior warnings are non-fatal."
